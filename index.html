<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cone Net & Base Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        /* Print styles - Strictly enforce physical dimensions */
        @media print {
            @page {
                size: letter portrait;
                margin: 0;
            }
            body {
                margin: 0;
                padding: 0;
                background: white;
            }
            .no-print {
                display: none !important;
            }
            .print-container {
                width: 100% !important;
                height: 100% !important;
                border: none !important;
                box-shadow: none !important;
                margin: 0 !important;
                overflow: hidden !important;
                position: relative;
                page-break-after: always;
            }
            canvas {
                width: 21.59cm !important;
                height: 27.94cm !important;
                max-width: none !important;
                max-height: none !important;
            }
            .page-break {
                page-break-before: always;
            }
        }
        
        /* Screen styles - Responsive scaling */
        .preview-container {
            /* Max width is physical size */
            max-width: 21.59cm;
            /* Width fills container but respects max */
            width: 100%;
            /* Maintain aspect ratio of US Letter (21.59 / 27.94 = ~0.7727) */
            aspect-ratio: 2159 / 2794;
            background: white;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            /* Height auto lets aspect-ratio drive the height */
            height: auto;
            position: relative;
        }

        /* Canvas fits the container on screen */
        .preview-container canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
            margin-top: -6px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: #e5e7eb;
            border-radius: 2px;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div id="root" class="flex items-center justify-center min-h-screen text-gray-500">
        Loading Application...
    </div>

    <script type="text/babel">
        console.log("Script starting...");

        if (typeof React === 'undefined' || typeof ReactDOM === 'undefined') {
            console.error("React libraries not loaded.");
            document.getElementById('root').innerHTML = "<div class='p-4 text-red-600 font-bold'>Error: React libraries failed to load. Please check your internet connection.</div>";
        }

        const { useState, useEffect, useRef } = React;

        const InputGroup = ({ label, value, onChange, min = 0, max = 30, step = 0.1, helpText }) => (
            // Added px-2 to provide an internal buffer for slider thumbs
            <div className="flex flex-col gap-1 flex-shrink-0 w-44 sm:w-48 px-2">
                <div className="flex justify-between items-center w-full">
                    <label className="text-xs font-medium text-gray-700">{label}</label>
                    <span className="text-xs font-mono text-gray-500">{value} cm</span>
                </div>
                <div className="flex items-center gap-2 w-full">
                    <input 
                        type="range" 
                        min={min} 
                        max={max} 
                        step={step} 
                        value={value} 
                        onChange={(e) => onChange(Number(e.target.value))}
                        className="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                    />
                    <input 
                        type="number" 
                        value={value} 
                        onChange={(e) => onChange(Number(e.target.value))}
                        className="w-14 px-1 py-1 border rounded text-sm text-right"
                        step={step}
                        min="0"
                    />
                </div>
                {helpText && <p className="text-[10px] text-gray-400 leading-tight w-full text-right">{helpText}</p>}
            </div>
        );

        const App = () => {
            const PPI = 96; 
            const CM_TO_INCH = 1 / 2.54;
            const PAGE_WIDTH_CM = 21.59;
            const PAGE_HEIGHT_CM = 27.94;
            const SCALE_FACTOR = 4; 
            
            const CANVAS_WIDTH_PX = PAGE_WIDTH_CM * CM_TO_INCH * PPI * SCALE_FACTOR;
            const CANVAS_HEIGHT_PX = PAGE_HEIGHT_CM * CM_TO_INCH * PPI * SCALE_FACTOR;
            const PIXELS_PER_CM = (PPI * CM_TO_INCH) * SCALE_FACTOR;

            // URL Parameter Helpers
            const getParam = (key, defaultVal) => {
                try {
                    const params = new URLSearchParams(window.location.search);
                    const val = params.get(key);
                    if (val === null) return defaultVal;
                    const parsed = parseFloat(val);
                    return isNaN(parsed) ? defaultVal : parsed;
                } catch (e) {
                    return defaultVal;
                }
            };

            const getBoolParam = (key, defaultVal) => {
                try {
                    const params = new URLSearchParams(window.location.search);
                    const val = params.get(key);
                    if (val === null) return defaultVal;
                    return val === 'true';
                } catch (e) {
                    return defaultVal;
                }
            };

            const [r1, setR1] = useState(() => getParam('r1', 3));
            const [r2, setR2] = useState(() => getParam('r2', 5));
            const [h, setH] = useState(() => getParam('h', 8));
            const [rc, setRc] = useState(() => getParam('rc', 1.5));
            const [isHalf, setIsHalf] = useState(() => getBoolParam('half', true));
            const [isGenerating, setIsGenerating] = useState(false);
            
            const coneCanvasRef = useRef(null);
            const baseCanvasRef = useRef(null);

            // Update URL on state change
            useEffect(() => {
                try {
                    const params = new URLSearchParams();
                    params.set('r1', r1);
                    params.set('r2', r2);
                    params.set('h', h);
                    params.set('rc', rc);
                    params.set('half', isHalf);
                    
                    const newRelativePathQuery = window.location.pathname + '?' + params.toString();
                    window.history.replaceState(null, '', newRelativePathQuery);
                } catch (e) {
                    // Ignore security errors
                }
            }, [r1, r2, h, rc, isHalf]);

            useEffect(() => {
                try {
                    drawCone();
                    drawBase();
                } catch (e) {
                    console.error("Error in draw function:", e);
                }
            }, [r1, r2, h, isHalf, rc]);

            // Shared Helpers
            const drawRuler = (ctx, label = "5 cm") => {
                ctx.save();
                const rulerMargin = 1.5 * PIXELS_PER_CM;
                const rulerLen = 5 * PIXELS_PER_CM;
                const rulerX = rulerMargin;
                const rulerY = rulerMargin + (1 * PIXELS_PER_CM); 

                ctx.beginPath();
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 4;
                ctx.moveTo(rulerX, rulerY);
                ctx.lineTo(rulerX + rulerLen, rulerY);
                ctx.stroke();
                
                // Draw ticks
                ctx.beginPath();
                ctx.lineWidth = 2;
                for (let i = 0; i <= 5; i++) {
                    const tickX = rulerX + (i * PIXELS_PER_CM);
                    const tickH = (i === 0 || i === 5) ? 10 : 6; 
                    ctx.moveTo(tickX, rulerY - tickH);
                    ctx.lineTo(tickX, rulerY + tickH);
                }
                ctx.stroke();

                ctx.fillStyle = 'black';
                ctx.font = `${12 * SCALE_FACTOR}px sans-serif`; 
                ctx.textAlign = 'left';
                ctx.textBaseline = 'bottom';
                ctx.fillText(label, rulerX, rulerY - 15);
                ctx.restore();
            };

            const drawPageBorder = (ctx) => {
                ctx.save();
                ctx.strokeStyle = '#e5e7eb';
                ctx.lineWidth = 2;
                ctx.setLineDash([20, 20]);
                ctx.strokeRect(0, 0, CANVAS_WIDTH_PX, CANVAS_HEIGHT_PX);
                ctx.restore();
            };

            // --- CONE DRAWING ---
            const drawCone = () => {
                const canvas = coneCanvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                
                if (canvas.width !== CANVAS_WIDTH_PX) canvas.width = CANVAS_WIDTH_PX;
                if (canvas.height !== CANVAS_HEIGHT_PX) canvas.height = CANVAS_HEIGHT_PX;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const r_top = Number(Math.min(r1, r2));
                const r_bottom = Number(Math.max(r1, r2));
                const height = Number(h);

                let geo = {};
                
                if (Math.abs(r_bottom - r_top) < 0.001) {
                    // Cylinder
                    const rectW = height; 
                    const rectH = 2 * Math.PI * r_bottom;
                    const startY = -rectH / 2;
                    const endY = isHalf ? 0 : rectH / 2;
                    
                    geo = { type: 'cylinder', rectW, rectH, startY, endY, minX: 0, maxX: rectW, minY: startY, maxY: endY };
                } else {
                    // Cone
                    const s = r_bottom - r_top;
                    const d_frustum = Math.sqrt(height * height + s * s);
                    const R_outer = (d_frustum * r_bottom) / s;
                    const R_inner = Math.max(0, R_outer - d_frustum);
                    const theta = (2 * Math.PI * r_bottom) / R_outer;
                    const startAngle = -theta / 2;
                    const endAngle = isHalf ? 0 : theta / 2;
                    
                    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                    const checkPoint = (r, ang) => {
                        const px = r * Math.cos(ang);
                        const py = r * Math.sin(ang);
                        if (px < minX) minX = px; if (px > maxX) maxX = px;
                        if (py < minY) minY = py; if (py > maxY) maxY = py;
                    };
                    checkPoint(R_inner, startAngle); checkPoint(R_inner, endAngle);
                    checkPoint(R_outer, startAngle); checkPoint(R_outer, endAngle);
                    const criticalAngles = [0, -Math.PI/2, -Math.PI]; 
                    if (!isHalf) criticalAngles.push(Math.PI/2, Math.PI);
                    criticalAngles.forEach(ang => {
                        if (ang >= startAngle && ang <= endAngle) {
                            checkPoint(R_inner, ang); checkPoint(R_outer, ang);
                        }
                    });

                    geo = { type: 'cone', R_inner, R_outer, startAngle, endAngle, minX, maxX, minY, maxY };
                }

                // Alignment
                let shiftX, shiftY;
                if (isHalf) {
                    shiftX = CANVAS_WIDTH_PX - (geo.maxX * PIXELS_PER_CM);
                    shiftY = CANVAS_HEIGHT_PX - (geo.maxY * PIXELS_PER_CM);
                } else {
                    const pageCX = (PAGE_WIDTH_CM * PIXELS_PER_CM) / 2;
                    const pageCY = (PAGE_HEIGHT_CM * PIXELS_PER_CM) / 2;
                    shiftX = pageCX - ((geo.minX + geo.maxX) / 2 * PIXELS_PER_CM);
                    shiftY = pageCY - ((geo.minY + geo.maxY) / 2 * PIXELS_PER_CM);
                }

                ctx.save();
                ctx.translate(shiftX, shiftY);
                ctx.scale(PIXELS_PER_CM, PIXELS_PER_CM);

                ctx.strokeStyle = 'black';
                ctx.lineWidth = 4 / PIXELS_PER_CM; 
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                if (geo.type === 'cylinder') {
                    ctx.beginPath();
                    ctx.rect(0, geo.startY, geo.rectW, geo.endY - geo.startY);
                    ctx.stroke();
                    
                    // Quarter Marks
                    ctx.save();
                    ctx.setLineDash([0.2, 0.2]); 
                    const quarterH = geo.rectH / 4;
                    const linesY = [-quarterH]; 
                    if (!isHalf) { linesY.push(0); linesY.push(quarterH); }
                    ctx.beginPath();
                    linesY.forEach(y => { ctx.moveTo(0, y); ctx.lineTo(geo.rectW, y); });
                    ctx.stroke();
                    ctx.restore();

                    ctx.fillStyle = '#000000';
                    ctx.font = `0.5px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText(`Cylinder Net${isHalf ? ' (Half)' : ''}`, geo.rectW/2, (geo.startY+geo.endY)/2);
                } else {
                    ctx.beginPath();
                    ctx.arc(0, 0, geo.R_inner, geo.startAngle, geo.endAngle, false);
                    ctx.lineTo(geo.R_outer * Math.cos(geo.endAngle), geo.R_outer * Math.sin(geo.endAngle));
                    ctx.arc(0, 0, geo.R_outer, geo.endAngle, geo.startAngle, true);
                    ctx.closePath();
                    ctx.stroke();

                    // Quarter Marks
                    ctx.save();
                    ctx.setLineDash([0.2, 0.2]); 
                    const quarterAngle = geo.startAngle / 2;
                    const angles = [quarterAngle];
                    if (!isHalf) { angles.push(0); angles.push(-quarterAngle); }
                    ctx.beginPath();
                    angles.forEach(ang => {
                        ctx.moveTo(geo.R_inner * Math.cos(ang), geo.R_inner * Math.sin(ang));
                        ctx.lineTo(geo.R_outer * Math.cos(ang), geo.R_outer * Math.sin(ang));
                    });
                    ctx.stroke();
                    ctx.restore();
                }
                ctx.restore();

                drawRuler(ctx, "5 cm");
                drawPageBorder(ctx);
            };

            // --- BASE DRAWING ---
            const drawBase = () => {
                const canvas = baseCanvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                
                if (canvas.width !== CANVAS_WIDTH_PX) canvas.width = CANVAS_WIDTH_PX;
                if (canvas.height !== CANVAS_HEIGHT_PX) canvas.height = CANVAS_HEIGHT_PX;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Calculations
                const P = 2 * Math.PI * r2;
                const effRc = Math.min(rc, r2);
                const L = (Math.PI / 2) * (r2 - effRc);
                
                const halfL = L / 2;
                
                const pageCX = (PAGE_WIDTH_CM * PIXELS_PER_CM) / 2;
                const pageCY = (PAGE_HEIGHT_CM * PIXELS_PER_CM) / 2;

                ctx.save();
                ctx.translate(pageCX, pageCY);
                ctx.scale(PIXELS_PER_CM, PIXELS_PER_CM);
                
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 4 / PIXELS_PER_CM; 
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                ctx.beginPath();
                // Top Edge (Left to Right)
                ctx.moveTo(-halfL, -(halfL + effRc));
                ctx.lineTo(halfL, -(halfL + effRc));
                // Top Right Corner
                ctx.arc(halfL, -halfL, effRc, -Math.PI/2, 0);
                // Right Edge
                ctx.lineTo(halfL + effRc, halfL);
                // Bottom Right Corner
                ctx.arc(halfL, halfL, effRc, 0, Math.PI/2);
                // Bottom Edge
                ctx.lineTo(-halfL, halfL + effRc);
                // Bottom Left Corner
                ctx.arc(-halfL, halfL, effRc, Math.PI/2, Math.PI);
                // Left Edge
                ctx.lineTo(-(halfL + effRc), -halfL);
                // Top Left Corner
                ctx.arc(-halfL, -halfL, effRc, Math.PI, -Math.PI/2);
                
                ctx.closePath();
                ctx.stroke();

                // Draw Diagonals
                ctx.save();
                ctx.setLineDash([0.1, 0.2]); 
                ctx.lineWidth = 2 / PIXELS_PER_CM;
                
                const distToCornerCenter = halfL * Math.sqrt(2);
                const distToEdge = distToCornerCenter + effRc;
                const lineExtent = distToEdge + 0.5;

                ctx.beginPath();
                const cos45 = Math.cos(Math.PI/4);
                const sin45 = Math.sin(Math.PI/4);
                
                ctx.moveTo(-lineExtent * cos45, -lineExtent * sin45);
                ctx.lineTo(lineExtent * cos45, lineExtent * sin45);

                ctx.moveTo(lineExtent * cos45, -lineExtent * sin45);
                ctx.lineTo(-lineExtent * cos45, lineExtent * sin45);
                
                ctx.stroke();
                ctx.restore();
                
                // Text Label
                ctx.fillStyle = '#666';
                ctx.font = `0.4px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`Base`, 0, -0.6);
                ctx.font = `0.3px sans-serif`;
                ctx.fillText(`r2=${r2}cm, rc=${effRc.toFixed(2)}cm`, 0, -0.2);

                ctx.restore();
                ctx.restore();

                drawRuler(ctx, "5 cm");
                drawPageBorder(ctx);
            };

            const downloadPDF = async (target) => {
                const canvas = target === 'base' ? baseCanvasRef.current : coneCanvasRef.current;
                const filename = target === 'base' ? 'mug-base-pattern.pdf' : 'mug-cone-pattern.pdf';
                
                if (!canvas) return;
                setIsGenerating(true);
                try {
                    if (!window.jspdf) throw new Error("jsPDF not loaded");
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF({
                        orientation: 'portrait',
                        unit: 'cm',
                        format: [21.59, 27.94]
                    });
                    const imgData = canvas.toDataURL('image/jpeg', 1.0);
                    doc.addImage(imgData, 'JPEG', 0, 0, 21.59, 27.94);
                    doc.save(filename);
                } catch (e) {
                    alert("PDF Error: " + e.message);
                }
                setIsGenerating(false);
            };

            // Layout Container: Fixed full viewport, no overflow on body
            return (
                <div className="flex flex-col h-screen w-screen overflow-hidden bg-gray-100">
                    
                    {/* Header: Auto-height based on content */}
                    <div className="flex-none bg-white border-b border-gray-200 p-2 shadow-sm no-print z-10 relative">
                        {/* Increased horizontal gap to gap-x-12 for better separation */}
                        <div className="w-full max-w-full mx-auto flex flex-wrap items-center justify-center gap-x-12 gap-y-4 px-4">
                            <InputGroup label="Top Radius (r1)" value={r1} onChange={setR1} />
                            <InputGroup label="Base Radius (r2)" value={r2} onChange={setR2} helpText="Sets total perimeter" />
                            <InputGroup label="Height (h)" value={h} onChange={setH} />
                            <InputGroup 
                                label="Base Corner (rc)" 
                                value={rc} 
                                onChange={setRc} 
                                max={r2}
                                helpText={`Max: ${r2}cm`}
                            />
                            
                            <div className="flex items-center gap-2 py-1 flex-shrink-0 px-2">
                                <input 
                                    type="checkbox" 
                                    id="halfPattern"
                                    checked={isHalf} 
                                    onChange={(e) => setIsHalf(e.target.checked)}
                                    className="w-5 h-5 text-blue-600 rounded focus:ring-blue-500 border-gray-300"
                                />
                                <label htmlFor="halfPattern" className="text-xs font-medium text-gray-700 cursor-pointer select-none leading-tight">
                                    Half Pattern<br/><span className="text-[10px] text-gray-500 font-normal">(Cone Only)</span>
                                </label>
                            </div>

                            <div className="flex gap-2 flex-shrink-0 px-2">
                                <button 
                                    onClick={() => downloadPDF('cone')}
                                    disabled={isGenerating}
                                    className="bg-blue-600 hover:bg-blue-700 disabled:bg-blue-400 text-white px-4 py-2 rounded-lg font-bold shadow-md transition-all active:scale-95 text-xs whitespace-nowrap"
                                >
                                    Cone PDF
                                </button>
                                <button 
                                    onClick={() => downloadPDF('base')}
                                    disabled={isGenerating}
                                    className="bg-emerald-600 hover:bg-emerald-700 disabled:bg-emerald-400 text-white px-4 py-2 rounded-lg font-bold shadow-md transition-all active:scale-95 text-xs whitespace-nowrap"
                                >
                                    Base PDF
                                </button>
                            </div>
                        </div>
                    </div>

                    {/* Content: Fills remaining space, handles own scrolling */}
                    <div className="flex-1 overflow-y-auto overflow-x-hidden p-4 bg-gray-100 w-full">
                        <div className="flex flex-col items-center gap-8 min-h-min w-full">
                            {/* Cone Preview */}
                            <div className="flex flex-col gap-2 items-center w-full">
                                <h2 className="text-lg font-semibold text-gray-600">Wall Pattern</h2>
                                <div className="preview-container print-container">
                                    <canvas 
                                        ref={coneCanvasRef}
                                        width={CANVAS_WIDTH_PX}
                                        height={CANVAS_HEIGHT_PX}
                                    />
                                </div>
                            </div>

                            {/* Base Preview */}
                            <div className="flex flex-col gap-2 items-center pb-8 w-full">
                                <h2 className="text-lg font-semibold text-gray-600">Base Pattern (Rounded Square)</h2>
                                <div className="preview-container print-container">
                                    <canvas 
                                        ref={baseCanvasRef}
                                        width={CANVAS_WIDTH_PX}
                                        height={CANVAS_HEIGHT_PX}
                                    />
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        try {
            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(<App />);
            console.log("React render called.");
        } catch (err) {
            console.error("Failed to render React app:", err);
            document.getElementById('root').innerHTML = "<div class='p-4 text-red-600'>Application Error: " + err.message + "</div>";
        }
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cone Net Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Add jsPDF library for reliable PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        /* Keep print styles as a fallback for Ctrl+P */
        @media print {
            @page {
                size: letter portrait;
                margin: 0;
            }
            body {
                margin: 0;
                padding: 0;
                background: white;
            }
            .no-print {
                display: none !important;
            }
            .print-container {
                width: 100% !important;
                height: 100% !important;
                border: none !important;
                box-shadow: none !important;
                margin: 0 !important;
                overflow: hidden !important;
                position: absolute;
                top: 0;
                left: 0;
            }
            canvas {
                width: 21.59cm !important;
                height: 27.94cm !important;
                max-width: none !important;
                max-height: none !important;
            }
        }
        
        .preview-container {
            width: 21.59cm;
            height: 27.94cm;
            background: white;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            margin: auto;
            position: relative;
        }

        .preview-wrapper {
            overflow: auto;
            background: #f3f4f6;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 2rem;
            min-height: 50vh;
        }
        
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
            margin-top: -6px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: #e5e7eb;
            border-radius: 2px;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Constants for US Letter
        const PPI = 96; 
        const CM_TO_INCH = 1 / 2.54;
        const PAGE_WIDTH_CM = 21.59;
        const PAGE_HEIGHT_CM = 27.94;
        
        // High resolution multiplier for crisp canvas lines
        const SCALE_FACTOR = 4; 
        
        // Calculate canvas pixel dimensions
        const CANVAS_WIDTH_PX = PAGE_WIDTH_CM * CM_TO_INCH * PPI * SCALE_FACTOR;
        const CANVAS_HEIGHT_PX = PAGE_HEIGHT_CM * CM_TO_INCH * PPI * SCALE_FACTOR;
        
        // Logical pixels per cm (for drawing commands)
        const PIXELS_PER_CM = (PPI * CM_TO_INCH) * SCALE_FACTOR;

        const InputGroup = ({ label, value, onChange, min = 0, max = 30, step = 0.1 }) => (
            <div className="flex flex-col gap-1 w-full md:w-auto">
                <div className="flex justify-between items-center">
                    <label className="text-xs font-medium text-gray-700">{label}</label>
                    <span className="text-xs font-mono text-gray-500">{value} cm</span>
                </div>
                <div className="flex items-center gap-2">
                    <input 
                        type="range" 
                        min={min} 
                        max={max} 
                        step={step} 
                        value={value} 
                        onChange={(e) => onChange(Number(e.target.value))}
                        className="w-32 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                    />
                    <input 
                        type="number" 
                        value={value} 
                        onChange={(e) => onChange(Number(e.target.value))}
                        className="w-16 px-2 py-1 border rounded text-sm text-right"
                        step={step}
                        min="0"
                    />
                </div>
            </div>
        );

        const App = () => {
            // Helper to safe parse floats from URL
            const getParam = (key, defaultVal) => {
                const params = new URLSearchParams(window.location.search);
                const val = params.get(key);
                if (val === null) return defaultVal;
                const parsed = parseFloat(val);
                return isNaN(parsed) ? defaultVal : parsed;
            };

            // Helper for boolean params
            const getBoolParam = (key, defaultVal) => {
                const params = new URLSearchParams(window.location.search);
                const val = params.get(key);
                if (val === null) return defaultVal;
                return val === 'true';
            };

            const [r1, setR1] = useState(() => getParam('r1', 3));
            const [r2, setR2] = useState(() => getParam('r2', 5));
            const [h, setH] = useState(() => getParam('h', 8));
            const [isHalf, setIsHalf] = useState(() => getBoolParam('half', true));
            const [isGenerating, setIsGenerating] = useState(false);
            const canvasRef = useRef(null);

            // Effect to update URL when state changes
            useEffect(() => {
                const params = new URLSearchParams();
                params.set('r1', r1);
                params.set('r2', r2);
                params.set('h', h);
                params.set('half', isHalf);
                
                // Update URL without reloading page
                const newRelativePathQuery = window.location.pathname + '?' + params.toString();
                window.history.replaceState(null, '', newRelativePathQuery);
            }, [r1, r2, h, isHalf]);

            useEffect(() => {
                draw();
            }, [r1, r2, h, isHalf]);

            const draw = () => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // White background (Critical for JPEG export)
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Inputs
                const r_top = Math.min(r1, r2);
                const r_bottom = Math.max(r1, r2);
                const height = h;

                // --- Geometry Calculation ---
                let boundingBox = { minX: 0, maxX: 0, minY: 0, maxY: 0, width: 0, height: 0, centerX: 0, centerY: 0 };
                let isCylinder = false;

                if (Math.abs(r_bottom - r_top) < 0.001) {
                    isCylinder = true;
                    // Orientation: Height along X, Circumference along Y to match Cone logic
                    const rectW = height; 
                    const rectH = 2 * Math.PI * r_bottom;
                    
                    // If half, we cut the circumference (rectH) in half, keeping the top part (y < 0)
                    const startY = -rectH / 2;
                    const endY = isHalf ? 0 : rectH / 2;
                    
                    // We define the rect relative to origin (0,0) being center-left
                    boundingBox = {
                        minX: 0,
                        maxX: rectW,
                        minY: startY,
                        maxY: endY,
                        width: rectW,
                        height: endY - startY,
                        centerX: rectW / 2,
                        centerY: (startY + endY) / 2
                    };
                } else {
                    const s = r_bottom - r_top;
                    const d_frustum = Math.sqrt(height * height + s * s);
                    const R_outer = (d_frustum * r_bottom) / s;
                    // FIX: Ensure R_inner is not negative due to floating point epsilon
                    const R_inner = Math.max(0, R_outer - d_frustum);
                    
                    const theta = (2 * Math.PI * r_bottom) / R_outer;

                    // Aligned with Horizontal Axis
                    // Top Half corresponds to negative angles (y < 0)
                    const startAngle = -theta / 2;
                    const endAngle = isHalf ? 0 : theta / 2;

                    // --- Calculate Bounding Box ---
                    const pointsToCheck = [];
                    const addPolar = (r, angle) => {
                        pointsToCheck.push({
                            x: r * Math.cos(angle),
                            y: r * Math.sin(angle)
                        });
                    };

                    addPolar(R_inner, startAngle);
                    addPolar(R_inner, endAngle);
                    addPolar(R_outer, startAngle);
                    addPolar(R_outer, endAngle);

                    const criticalAngles = [0, -Math.PI / 2, -Math.PI]; 
                    if (!isHalf) criticalAngles.push(Math.PI / 2, Math.PI);

                    criticalAngles.forEach(ang => {
                        if (ang >= startAngle && ang <= endAngle) {
                            addPolar(R_inner, ang);
                            addPolar(R_outer, ang);
                        }
                    });
                    
                    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                    pointsToCheck.forEach(p => {
                        if (p.x < minX) minX = p.x;
                        if (p.x > maxX) maxX = p.x;
                        if (p.y < minY) minY = p.y;
                        if (p.y > maxY) maxY = p.y;
                    });

                    boundingBox = {
                        minX, maxX, minY, maxY,
                        width: maxX - minX,
                        height: maxY - minY,
                        centerX: (minX + maxX) / 2,
                        centerY: (minY + maxY) / 2
                    };
                }

                // --- Rendering ---
                let shiftX, shiftY;

                if (isHalf) {
                    // Align Bottom-Right with NO margins
                    // The center line aligns with the paper edge
                    shiftX = CANVAS_WIDTH_PX - (boundingBox.maxX * PIXELS_PER_CM);
                    shiftY = CANVAS_HEIGHT_PX - (boundingBox.maxY * PIXELS_PER_CM);
                } else {
                    // Center
                    const pageCX = (PAGE_WIDTH_CM * PIXELS_PER_CM) / 2;
                    const pageCY = (PAGE_HEIGHT_CM * PIXELS_PER_CM) / 2;
                    shiftX = pageCX - (boundingBox.centerX * PIXELS_PER_CM);
                    shiftY = pageCY - (boundingBox.centerY * PIXELS_PER_CM);
                }

                ctx.save();
                ctx.translate(shiftX, shiftY);
                ctx.scale(PIXELS_PER_CM, PIXELS_PER_CM);

                // Draw Style: Black and Thicker
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 4 / PIXELS_PER_CM; // Thicker logical line width
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                if (isCylinder) {
                    const rectW = height; 
                    const rectH = 2 * Math.PI * r_bottom;
                    const startY = -rectH / 2;
                    const endY = isHalf ? 0 : rectH / 2;
                    
                    ctx.beginPath();
                    ctx.rect(0, startY, rectW, endY - startY);
                    ctx.stroke();
                    
                    ctx.fillStyle = '#000000';
                    ctx.font = `0.5px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText(`Cylinder${isHalf ? ' (Half)' : ''}`, rectW/2, (startY+endY)/2);
                } else {
                    const s = r_bottom - r_top;
                    const d_frustum = Math.sqrt(height * height + s * s);
                    const R_outer = (d_frustum * r_bottom) / s;
                    const R_inner = Math.max(0, R_outer - d_frustum);
                    const theta = (2 * Math.PI * r_bottom) / R_outer;
                    const startAngle = -theta / 2;
                    const endAngle = isHalf ? 0 : theta / 2;

                    ctx.beginPath();
                    // Inner Arc
                    ctx.arc(0, 0, R_inner, startAngle, endAngle, false);
                    // Line to outer
                    ctx.lineTo(R_outer * Math.cos(endAngle), R_outer * Math.sin(endAngle));
                    // Outer Arc (drawn backwards)
                    ctx.arc(0, 0, R_outer, endAngle, startAngle, true);
                    // Close
                    ctx.closePath();
                    ctx.stroke();
                }

                ctx.restore();

                // Draw Calibration Ruler - Top Left
                ctx.save();
                const rulerMargin = 1.5 * PIXELS_PER_CM; // Slightly more margin
                const rulerLen = 5 * PIXELS_PER_CM;
                const rulerX = rulerMargin;
                const rulerY = rulerMargin + (1 * PIXELS_PER_CM); // Push down slightly for text

                ctx.beginPath();
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 4; // Screen pixels (consistent thickness)
                ctx.moveTo(rulerX, rulerY);
                ctx.lineTo(rulerX + rulerLen, rulerY);
                ctx.stroke();
                
                // Tick marks
                ctx.beginPath();
                ctx.lineWidth = 2;
                ctx.moveTo(rulerX, rulerY - 10);
                ctx.lineTo(rulerX, rulerY + 10);
                ctx.moveTo(rulerX + rulerLen, rulerY - 10);
                ctx.lineTo(rulerX + rulerLen, rulerY + 10);
                ctx.stroke();

                ctx.fillStyle = 'black';
                ctx.font = `${12 * SCALE_FACTOR}px sans-serif`; 
                ctx.textAlign = 'left';
                ctx.textBaseline = 'bottom';
                ctx.fillText('5 cm Scale Check', rulerX, rulerY - 15);
                
                // Draw Page Border
                ctx.strokeStyle = '#e5e7eb';
                ctx.lineWidth = 2;
                ctx.setLineDash([20, 20]);
                ctx.strokeRect(0, 0, CANVAS_WIDTH_PX, CANVAS_HEIGHT_PX);
                
                ctx.restore();
            };

            const downloadPDF = async () => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                
                setIsGenerating(true);

                try {
                    // Use jsPDF to generate a PDF file directly
                    // This bypasses browser print dialog issues and ensures strict dimensions
                    const { jsPDF } = window.jspdf;
                    
                    // Create PDF: Portrait, units: cm, size: letter
                    // Standard US Letter: 21.59cm x 27.94cm
                    const doc = new jsPDF({
                        orientation: 'portrait',
                        unit: 'cm',
                        format: [21.59, 27.94]
                    });

                    // Convert canvas to high-quality JPEG
                    const imgData = canvas.toDataURL('image/jpeg', 1.0);

                    // Add image to PDF covering the full page
                    // The canvas is already drawn to exactly match these proportions
                    doc.addImage(imgData, 'JPEG', 0, 0, 21.59, 27.94);

                    // Download
                    doc.save('cone-pattern.pdf');
                } catch (e) {
                    console.error("PDF generation failed:", e);
                    alert("Could not generate PDF. Please try again.");
                }
                
                setIsGenerating(false);
            };

            return (
                <div className="flex flex-col min-h-screen">
                    <div className="bg-white border-b border-gray-200 p-4 shadow-sm no-print z-10 relative">
                        <div className="max-w-6xl mx-auto flex flex-col xl:flex-row items-center justify-between gap-6">
                            <div>
                                <h1 className="text-2xl font-bold text-gray-900">Cone Net Generator</h1>
                                <p className="text-sm text-gray-500">Enter measurements in cm. Download PDF to print.</p>
                            </div>
                            
                            <div className="flex flex-col sm:flex-row gap-6 items-center bg-gray-50 p-4 rounded-xl border border-gray-200 shadow-sm">
                                <InputGroup label="Top Radius (r1)" value={r1} onChange={setR1} />
                                <InputGroup label="Base Radius (r2)" value={r2} onChange={setR2} />
                                <InputGroup label="Height (h)" value={h} onChange={setH} />
                                
                                <div className="flex items-center gap-2 border-l pl-4 border-gray-300">
                                    <input 
                                        type="checkbox" 
                                        id="halfPattern"
                                        checked={isHalf} 
                                        onChange={(e) => setIsHalf(e.target.checked)}
                                        className="w-5 h-5 text-blue-600 rounded focus:ring-blue-500 border-gray-300"
                                    />
                                    <label htmlFor="halfPattern" className="text-sm font-medium text-gray-700 cursor-pointer select-none">
                                        Half Pattern<br/><span className="text-xs text-gray-500 font-normal">(Symmetric)</span>
                                    </label>
                                </div>
                            </div>
                            
                            <button 
                                onClick={downloadPDF}
                                disabled={isGenerating}
                                className="bg-blue-600 hover:bg-blue-700 disabled:bg-blue-400 text-white px-6 py-3 rounded-xl font-bold shadow-md transition-all flex items-center gap-2 active:scale-95 whitespace-nowrap"
                            >
                                {isGenerating ? (
                                    <span>Generating...</span>
                                ) : (
                                    <>
                                        <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                        <path fillRule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clipRule="evenodd" />
                                        </svg>
                                        Download PDF
                                    </>
                                )}
                            </button>
                        </div>
                    </div>

                    <div className="flex-1 preview-wrapper">
                        <div className="preview-container print-container">
                            <canvas 
                                ref={canvasRef}
                                width={CANVAS_WIDTH_PX}
                                height={CANVAS_HEIGHT_PX}
                                className="w-full h-full block"
                            />
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
